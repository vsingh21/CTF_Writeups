from pwn import *
import re
import MPoly1305
from tkinter import Tk

tk = Tk()
# Start the process (modify if connecting remotely)
p = process(["python", "raw_chall.py"])  # Change to actual script path
#p = remote('activist-birds.picoctf.net',63900)
def extract_hex(line):
    return re.search(r'([0-9a-fA-F]+)', line).group(1)

# Read output and extract values
p.recvuntil(b"Plaintext: ")
plaintext1 = p.recvline().strip().decode()
p.recvuntil(b"Plaintext (hex): ")
plaintext1_hex = extract_hex(p.recvline().strip().decode())
print(p.recvuntil(b"Ciphertext (hex): "))
ciphertext1 = extract_hex(p.recvline().strip().decode())

p.recvuntil(b"Plaintext: ")
plaintext2 = p.recvline().strip().decode()
p.recvuntil(b"Plaintext (hex): ")
plaintext2_hex = extract_hex(p.recvline().strip().decode())
p.recvuntil(b"Ciphertext (hex): ")
ciphertext2 = extract_hex(p.recvline().strip().decode())

# Extract nonce and tag
nonce1, tag1 = ciphertext1[-24:], ciphertext1[-56:-24]
nonce2, tag2 = ciphertext2[-24:], ciphertext2[-56:-24]
ciphertext1 = ciphertext1[:-56]
ciphertext2 = ciphertext2[:-56]

print(f"Nonce reused? {nonce1 == nonce2}")



pt1 = binascii.unhexlify(plaintext1_hex)
pt2 = binascii.unhexlify(plaintext2_hex)
ct1 = binascii.unhexlify(ciphertext1)
ct2 = binascii.unhexlify(ciphertext2)
ks = bytes(x ^ y for x, y in zip(pt1, ct1))
ks2 = bytes(x ^ y for x, y in zip(pt2, ct2))
ks_shared = ks[:len(ks2)]
print(f"Keystream shared? {ks2 == ks_shared}")

# p = 2**130 - 5
tag1num = int.from_bytes(binascii.unhexlify(tag1), byteorder='little', signed=False)
tag2num = int.from_bytes(binascii.unhexlify(tag2), byteorder='little', signed=False)
tagdiff = (tag1num - tag2num) % (2**130 - 5)
print(f"Tag 1 num: {tag1num}")
print(f"Tag 2 num: {tag2num}")
print(f"Tags Diff: {tagdiff}")

def poly1305_coefficients(data: bytes) -> list[int]:
    # Prime modulus used in Poly1305
    coefficients = []
    chunks = [data[i:i+16] for i in range(0, len(data), 16)]
    print([chunk.hex() for chunk in chunks])
    for chunk in chunks:
        # Convert chunk to little-endian integer
        chunk_int = int.from_bytes(chunk + b'\x01', byteorder='little')
        coefficients.append(chunk_int)
    
    return coefficients

coeffs1 = poly1305_coefficients(ct1 + bytes.fromhex("00000000000000000000004d00000000000000"))
coeffs2 = poly1305_coefficients(ct2 + bytes.fromhex("0000000000000000000000000000000000004600000000000000"))
while len(coeffs1) < len(coeffs2):
    coeffs1 = [0] + coeffs1
coeffDiffs = [coeffs1[i] - coeffs2[i] for i in range(len(coeffs1))]
print(f"Tag 1 Coeffs: {coeffs1}")
print(f"Tag 2 Coeffs: {coeffs2}")
print(f"Diffs Coeffs: {coeffDiffs}")

def find_valid_r(coeffs, tagdiff):
    p = 2**130 - 5  # Prime modulus
    GF = GF(p)
    possible_rs = []

    # Iterate over possible k values: -4, -3, ..., 4
    for k in range(1):
        print(f"Trying k = {k}")
        rhs = -(tagdiff + k * (2**128)) % p
        
        # Polynomial coefficients: c1 r^5 + c2 r^4 + c3 r^3 + c2 r^2 + c1 r - rhs
        poly = GF(coeffs[0]) * x^5 + GF(coeffs[1]) * x^4 + GF(coeffs[2]) * x^3 \
               + GF(coeffs[3]) * x^2 + GF(coeffs[4]) * x - GF(rhs)
        
        roots = poly.roots(multiplicities=False)
        possible_rs.extend(roots)
    
    # Filter roots based on Poly1305 key constraints
    valid_rs = []
    for r in possible_rs:
        r_int = Integer(r)
        # Convert to 16-byte little-endian
        r_bytes = r_int.to_bytes(16, byteorder='little')
        
        # Check top 4 bits of bytes 3,7,11,15 are clear
        if any((r_bytes[i] & 0xF0) != 0 for i in [3, 7, 11, 15]):
            continue
        
        # Check bottom 2 bits of bytes 4,8,12 are clear
        if any((r_bytes[i] % 4) != 0 for i in [4, 8, 12]):
            continue
        
        valid_rs.append(r_bytes)
    
    return valid_rs

print(f"coeffs1 = {coeffs1}")
print(f"coeffs2 = {coeffs2}")
print(f"diff_coeffs = {coeffDiffs}")
print(f"tag1 = {tag1num}")
print(f"tag2 = {tag2num}")
print(f"tagdiff = {tagdiff}")
tk.withdraw()
tk.clipboard_clear()
tk.clipboard_append(
    f"coeffs1 = {coeffs1}\n" + \
    f"coeffs2 = {coeffs2}\n" + \
    f"diff_coeffs = {coeffDiffs}\n" + \
    f"tag1 = {tag1num}\n" + \
    f"tag2 = {tag2num}\n" +\
    f"tagdiff = {tagdiff}"
)
r = int(input("Give me the sagemath R input: "))
s = int(input("Give me the sagemath S input: "))

def forge_tag(message, r, s):
    r = r & 0x0ffffffc0ffffffc0ffffffc0fffffff
    coeffs = poly1305_coefficients(message)
    acc = 0
    p = (1 << 130) - 5
    for i in range(len(coeffs)):
        acc += coeffs[i] % p
        acc = (acc * r) % p
    acc = (acc + s) % (1 << 128)
    return acc.to_bytes(16, 'little')

goal = "But it's only secure if used correctly!"
goal_hex = goal.encode().hex()
raw_goal_hex = binascii.unhexlify(goal_hex)
goal_ct = bytes(x ^ y for x, y in zip(raw_goal_hex, ks[:len(raw_goal_hex)]))
padded_goal_ct = goal_ct + bytes.fromhex("00000000000000000000000000000000002700000000000000")

#r, s = ...
#nonce = nonce1
#MPoly = MPoly1305.new(r=r, s=s, nonce=nonce,data=goal_ct)
#tag = MPoly.hexdigest()
nonce = nonce1
tag = forge_tag(padded_goal_ct, r, s).hex()
# Print extracted values
print(f"PT1: {plaintext1_hex}\nCT1: {ciphertext1}\nKS1: {ks.hex()} \nTag 1: {tag1}\nNonce 1: {nonce1}\n")
print(f"PT2: {plaintext2_hex}\nCT2: {ciphertext2}\nKS2: {ks2.hex()} \nTag 2: {tag2}\nNonce 2: {nonce2}\n")
print(f"PTG: {goal_hex}")
print()
print(f"Ciphertext: {goal_ct.hex()}")
print('\033[1m' + f"Tag       : {tag}" + '\033[0m')
print(f"Nonce     : {nonce}")
#print(f"Keystream: {ks.hex()}")
flag = goal_ct.hex() + str(tag) + str(nonce)
print(f"My Flag   : {flag}")
#print(p.recvuntil(b"Goal Ciphertext (hex): "))
#print()
#print()
#true_goal_ct = p.recvline().strip().decode()
#print(f"True Flag: {true_goal_ct}")
p.interactive()
# Close process
#p.close()
